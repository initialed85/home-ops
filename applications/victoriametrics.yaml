apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: victoria-metrics
  namespace: argo-cd
spec:
  destination:
    namespace: monitoring
    server: https://kubernetes.default.svc
  project: default
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true
      - ServerSideApply=true
  ignoreDifferences:
    - kind: Service
      jqPathExpressions:
        - ".spec.ports[].nodePort"
    - group: apps
      kind: Deployment
      jsonPointers:
        - /spec/template/spec/initContainers/0/resources
        - /spec/template/spec/initContainers/1/resources
        - /spec/template/spec/initContainers/2/resources
        - /spec/template/spec/containers/0/resources
        - /spec/template/spec/containers/1/resources
        - /spec/template/spec/containers/2/resources
    - group: apps
      kind: StatefulSet
      jsonPointers:
        - /spec/template/spec/initContainers/0/resources
        - /spec/template/spec/initContainers/1/resources
        - /spec/template/spec/initContainers/2/resources
        - /spec/template/spec/containers/0/resources
        - /spec/template/spec/containers/1/resources
        - /spec/template/spec/containers/2/resources
    - group: apps
      kind: DaemonSet
      jsonPointers:
        - /spec/template/spec/initContainers/0/resources
        - /spec/template/spec/initContainers/1/resources
        - /spec/template/spec/initContainers/2/resources
        - /spec/template/spec/containers/0/resources
        - /spec/template/spec/containers/1/resources
        - /spec/template/spec/containers/2/resources
  sources:
    - chart: victoria-metrics-k8s-stack
      targetRevision: 0.27.0
      repoURL: https://victoriametrics.github.io/helm-charts/
      helm:
        releaseName: vm
        valuesObject:
          global:
            # -- Cluster label to use for dashboards and rules
            clusterLabel: cluster
            # -- Global license configuration
            license:
              key: ""
              keyRef:
                {}
                # name: secret-license
                # key: license

          # -- Resource full name suffix override
          nameOverride: ""
          # -- Resource full name prefix override
          fullnameOverride: ""
          # -- Tenant to use for Grafana datasources and remote write
          tenant: "0"
          # -- If this chart is used in "Argocd" with "releaseName" field then
          # VMServiceScrapes couldn't select the proper services.
          # For correct working need set value 'argocdReleaseOverride=$ARGOCD_APP_NAME'
          argocdReleaseOverride: ""

          # -- VictoriaMetrics Operator dependency chart configuration. More values can be found [here](https://docs.victoriametrics.com/helm/victoriametrics-operator#parameters). Also checkout [here](https://docs.victoriametrics.com/operator/vars) possible ENV variables to configure operator behaviour
          victoria-metrics-operator:
            enabled: true
            serviceMonitor:
              enabled: true
            crd:
              create: false
              cleanup:
                enabled: true
                image:
                  repository: bitnami/kubectl
                  pullPolicy: IfNotPresent
            operator:
              # -- By default, operator converts prometheus-operator objects.
              disable_prometheus_converter: false

          serviceAccount:
            # -- Specifies whether a service account should be created
            create: true
            # -- Annotations to add to the service account
            annotations: {}
            # -- The name of the service account to use.
            # If not set and create is true, a name is generated using the fullname template
            name: ""

          # -- Enable dashboards despite it's dependency is not installed
          dashboards:
            vmalert: false
            operator: false
            # -- In ArgoCD using client-side apply this dashboard reaches annotations size limit and causes k8s issues without server side apply
            # See [this issue](https://github.com/VictoriaMetrics/helm-charts/tree/disable-node-exporter-dashboard-by-default/charts/victoria-metrics-k8s-stack#metadataannotations-too-long-must-have-at-most-262144-bytes-on-dashboards)
            node-exporter-full: true

          # -- Create default rules for monitoring the cluster
          defaultRules:
            create: true

            # -- Common properties for VMRule groups
            group:
              spec:
                # -- Optional HTTP URL parameters added to each rule request
                params: {}

            # -- Common properties for all VMRules
            rule:
              spec:
                # -- Additional labels for all VMRules
                labels: {}
                # -- Additional annotations for all VMRules
                annotations: {}

            # -- Common properties for VMRules alerts
            alerting:
              spec:
                # -- Additional labels for VMRule alerts
                labels: {}
                # -- Additional annotations for VMRule alerts
                annotations: {}

            # -- Common properties for VMRules recording rules
            recording:
              spec:
                # -- Additional labels for VMRule recording rules
                labels: {}
                # -- Additional annotations for VMRule recording rules
                annotations: {}

            # -- Per rule properties
            rules:
              {}
              # CPUThrottlingHigh:
              #   create: true
              #   spec:
              #     for: 15m
              #     labels:
              #       severity: critical
            # -- Rule group properties
            groups:
              etcd:
                create: true
                # -- Common properties for all rules in a group
                rules: {}
                # spec:
                #   annotations:
                #     dashboard: https://example.com/dashboard/1
              general:
                create: true
                rules: {}
              k8sContainerMemoryRss:
                create: true
                rules: {}
              k8sContainerMemoryCache:
                create: true
                rules: {}
              k8sContainerCpuUsageSecondsTotal:
                create: true
                rules: {}
              k8sPodOwner:
                create: true
                rules: {}
              k8sContainerResource:
                create: true
                rules: {}
              k8sContainerMemoryWorkingSetBytes:
                create: true
                rules: {}
              k8sContainerMemorySwap:
                create: true
                rules: {}
              kubeApiserver:
                create: true
                rules: {}
              kubeApiserverAvailability:
                create: true
                rules: {}
              kubeApiserverBurnrate:
                create: true
                rules: {}
              kubeApiserverHistogram:
                create: true
                rules: {}
              kubeApiserverSlos:
                create: true
                rules: {}
              kubelet:
                create: true
                rules: {}
              kubePrometheusGeneral:
                create: true
                rules: {}
              kubePrometheusNodeRecording:
                create: true
                rules: {}
              kubernetesApps:
                create: true
                rules: {}
                targetNamespace: ".*"
              kubernetesResources:
                create: true
                rules: {}
              kubernetesStorage:
                create: true
                rules: {}
                targetNamespace: ".*"
              kubernetesSystem:
                create: true
                rules: {}
              kubernetesSystemKubelet:
                create: true
                rules: {}
              kubernetesSystemApiserver:
                create: true
                rules: {}
              kubernetesSystemControllerManager:
                create: true
                rules: {}
              kubeScheduler:
                create: true
                rules: {}
              kubernetesSystemScheduler:
                create: true
                rules: {}
              kubeStateMetrics:
                create: true
                rules: {}
              nodeNetwork:
                create: true
                rules: {}
              node:
                create: true
                rules: {}
              vmagent:
                create: true
                rules: {}
              vmsingle:
                create: true
                rules: {}
              vmcluster:
                create: true
                rules: {}
              vmHealth:
                create: true
                rules: {}
              vmoperator:
                create: true
                rules: {}
              alertmanager:
                create: true
                rules: {}

            # -- Runbook url prefix for default rules
            runbookUrl: https://runbooks.prometheus-operator.dev/runbooks

            # -- Labels for default rules
            labels: {}
            # -- Annotations for default rules
            annotations: {}

          # -- Create default dashboards
          defaultDashboardsEnabled: true

          # -- Create experimental dashboards
          experimentalDashboardsEnabled: true

          # -- Create dashboards as CRDs (reuqires grafana-operator to be installed)
          grafanaOperatorDashboardsFormat:
            enabled: false
            instanceSelector:
              matchLabels:
                dashboards: "grafana"
            allowCrossNamespaceImport: false

          # -- Provide custom recording or alerting rules to be deployed into the cluster.
          additionalVictoriaMetricsMap:
          #    rule-name:
          #     groups:
          #     - name: my_group
          #       rules:
          #       - record: my_record
          #         expr: 100 * my_record

          # -- External VM read and write URLs
          externalVM:
            read:
              url: ""
              # bearerTokenSecret:
              #   name: dbaas-read-access-token
              #   key: bearerToken
            write:
              url: ""
              # bearerTokenSecret:
              #   name: dbaas-read-access-token
              #   key: bearerToken

          # Configures vmsingle params

          vmsingle:
            # -- VMSingle annotations
            annotations: {}
            # -- Create VMSingle CR
            enabled: true
            # -- Full spec for VMSingle CRD. Allowed values describe [here](https://docs.victoriametrics.com/operator/api#vmsinglespec)
            spec:
              nodeSelector:
                kubernetes.io/arch: amd64
              port: "8429"
              image:
                tag: v1.104.0
              # -- Data retention period. Possible units character: h(ours), d(ays), w(eeks), y(ears), if no unit character specified - month. The minimum retention period is 24h. See these [docs](https://docs.victoriametrics.com/single-server-victoriametrics/#retention)
              retentionPeriod: "1"
              replicaCount: 1
              extraArgs: {}
              storage:
                storageClassName: "nfs-ssd"
                accessModes:
                  - ReadWriteOnce
                resources:
                  requests:
                    storage: 64Gi
            ingress:
              # -- Enable deployment of ingress for server component
              enabled: true
              # -- Ingress annotations
              annotations:
                # kubernetes.io/ingress.class: traefik
                # kubernetes.io/tls-acme: "true"
                cert-manager.io/cluster-issuer: letsencrypt
                # (namespace)-(name)@kubernetescrd
                traefik.ingress.kubernetes.io/router.middlewares: monitoring-victorialogs-whitelist@kubernetescrd
              # -- Ingress extra labels
              labels: {}
              # -- Ingress default path
              path: ""
              # -- Ingress path type
              pathType: Prefix
              # -- Ingress controller class name
              ingressClassName: "traefik"

              # -- Array of host objects
              hosts:
                - vmsingle.initialed85.cc

              # -- Extra paths to prepend to every host configuration. This is useful when working with annotation based services.
              extraPaths: []
              # - path: /*
              #   pathType: Prefix
              #   backend:
              #     service:
              #       name: ssl-redirect
              #       port:
              #         name: service

              # -- Array of TLS objects
              tls:
                - secretName: vmsingle-ingress-tls
                  hosts:
                    - vmsingle.initialed85.cc

          vmcluster:
            # -- Create VMCluster CR
            enabled: false
            # -- VMCluster annotations
            annotations: {}
            # -- Full spec for VMCluster CRD. Allowed values described [here](https://docs.victoriametrics.com/operator/api#vmclusterspec)
            spec:
              nodeSelector:
                kubernetes.io/arch: amd64
              # -- Data retention period. Possible units character: h(ours), d(ays), w(eeks), y(ears), if no unit character specified - month. The minimum retention period is 24h. See these [docs](https://docs.victoriametrics.com/single-server-victoriametrics/#retention)
              retentionPeriod: "1"
              replicationFactor: 2
              vmstorage:
                image:
                  tag: v1.104.0-cluster
                replicaCount: 2
                storageDataPath: "/vm-data"
                storage:
                  volumeClaimTemplate:
                    spec:
                      resources:
                        requests:
                          storage: 10Gi
                # resources:
                #   {}
                # limits:
                #   cpu: "1"
                #   memory: 1500Mi
              vmselect:
                port: "8481"
                image:
                  tag: v1.104.0-cluster
                replicaCount: 2
                cacheMountPath: "/select-cache"
                extraArgs: {}
                storage:
                  volumeClaimTemplate:
                    spec:
                      resources:
                        requests:
                          storage: 2Gi
                # resources:
                #   {}
                # limits:
                #   cpu: "1"
                #   memory: "1000Mi"
                # requests:
                #   cpu: "0.5"
                #   memory: "500Mi"
              vminsert:
                port: "8480"
                image:
                  tag: v1.104.0-cluster
                replicaCount: 2
                extraArgs: {}
                # resources:
                #   {}
                # limits:
                #   cpu: "1"
                #   memory: 1000Mi
                # requests:
                #   cpu: "0.5"
                #   memory: "500Mi"

            ingress:
              storage:
                # -- Enable deployment of ingress for server component
                enabled: false

                # -- Ingress annotations
                annotations:
                  {}
                  # kubernetes.io/ingress.class: traefik
                  # kubernetes.io/tls-acme: "true"

                # -- Ingress extra labels
                labels: {}

                # -- Ingress controller class name
                ingressClassName: "traefik"

                # -- Ingress path type
                pathType: Prefix

                # -- Ingress default path
                path: ""

                # -- Array of host objects
                hosts: []
                #  - vmstorage.domain.com

                # -- Extra paths to prepend to every host configuration. This is useful when working with annotation based services.
                extraPaths: []
                # - path: /*
                #   pathType: Prefix
                #   backend:
                #     service:
                #       name: ssl-redirect
                #       port:
                #         name: service

                # -- Array of TLS objects
                tls: []
                #  - secretName: vmstorage-ingress-tls
                #    hosts:
                #      - vmstorage.domain.com
              select:
                # -- Enable deployment of ingress for server component
                enabled: false

                # -- Ingress annotations
                annotations:
                  {}
                  # kubernetes.io/ingress.class: traefik
                  # kubernetes.io/tls-acme: "true"

                # -- Ingress extra labels
                labels: {}

                # -- Ingress controller class name
                ingressClassName: "traefik"

                # -- Ingress path type
                pathType: Prefix

                # -- Ingress default path
                path: '{{ dig "extraArgs" "http.pathPrefix" "/" .Values.vmcluster.spec.vmselect }}'

                # -- Array of host objects
                hosts: []
                #  - vmselect.domain.com
                # -- Extra paths to prepend to every host configuration. This is useful when working with annotation based services.
                extraPaths: []
                # - path: /*
                #   pathType: Prefix
                #   backend:
                #     service:
                #       name: ssl-redirect
                #       port:
                #         name: service

                # -- Array of TLS objects
                tls: []
                #  - secretName: vmselect-ingress-tls
                #    hosts:
                #      - vmselect.domain.com
              insert:
                # -- Enable deployment of ingress for server component
                enabled: false

                # -- Ingress annotations
                annotations:
                  {}
                  # kubernetes.io/ingress.class: traefik
                  # kubernetes.io/tls-acme: "true"

                # -- Ingress extra labels
                labels: {}

                # -- Ingress controller class name
                ingressClassName: "traefik"

                # -- Ingress path type
                pathType: Prefix

                # -- Ingress default path
                path: '{{ dig "extraArgs" "http.pathPrefix" "/" .Values.vmcluster.spec.vminsert }}'

                # -- Array of host objects
                hosts: []
                #  - vminsert.domain.com
                # -- Extra paths to prepend to every host configuration. This is useful when working with annotation based services.
                extraPaths: []
                # - path: /*
                #   pathType: Prefix
                #   backend:
                #     service:
                #       name: ssl-redirect
                #       port:
                #         name: service

                # -- Array of TLS objects
                tls: []
                #  - secretName: vminsert-ingress-tls
                #    hosts:
                #      - vminsert.domain.com

          alertmanager:
            # -- Create VMAlertmanager CR
            enabled: true
            # -- Alertmanager annotations
            annotations: {}
            # -- (object) Full spec for VMAlertmanager CRD. Allowed values described [here](https://docs.victoriametrics.com/operator/api#vmalertmanagerspec)
            spec:
              nodeSelector:
                kubernetes.io/arch: amd64
              port: "9093"
              selectAllByDefault: true
              image:
                tag: v0.25.0
              externalURL: ""
              routePrefix: /

              # -- (string) If this one defined, it will be used for alertmanager configuration and config parameter will be ignored
              configSecret: ""
            # -- (object) Alertmanager configuration
            config:
              templates:
                - "/etc/vm/configs/**/*.tmpl"
              route:
                # group_by: ["alertgroup", "job"]
                # group_wait: 30s
                # group_interval: 5m
                # repeat_interval: 12h
                receiver: "blackhole"
                ## routes:
                ###################################################
                ## Duplicate code_owner routes to teams
                ## These will send alerts to team channels but continue
                ## processing through the rest of the tree to handled by on-call
                # - matchers:
                #     - code_owner_channel!=""
                #     - severity=~"info|warning|critical"
                #   group_by: ["code_owner_channel", "alertgroup", "job"]
                #   receiver: slack-code-owners
                # ###################################################
                # ## Standard on-call routes
                # - matchers:
                #     - severity=~"info|warning|critical"
                #   receiver: slack-monitoring
                #   continue: true

              # inhibit_rules:
              #   - target_matchers:
              #       - severity=~"warning|info"
              #     source_matchers:
              #       - severity=critical
              #     equal:
              #       - cluster
              #       - namespace
              #       - alertname
              #   - target_matchers:
              #       - severity=info
              #     source_matchers:
              #       - severity=warning
              #     equal:
              #       - cluster
              #       - namespace
              #       - alertname
              #   - target_matchers:
              #       - severity=info
              #     source_matchers:
              #       - alertname=InfoInhibitor
              #     equal:
              #       - cluster
              #       - namespace

              receivers:
                - name: blackhole
                # - name: "slack-monitoring"
                #   slack_configs:
                #     - channel: "#channel"
                #       send_resolved: true
                #       title: '{{ template "slack.monzo.title" . }}'
                #       icon_emoji: '{{ template "slack.monzo.icon_emoji" . }}'
                #       color: '{{ template "slack.monzo.color" . }}'
                #       text: '{{ template "slack.monzo.text" . }}'
                #       actions:
                #         - type: button
                #           text: "Runbook :green_book:"
                #           url: "{{ (index .Alerts 0).Annotations.runbook_url }}"
                #         - type: button
                #           text: "Query :mag:"
                #           url: "{{ (index .Alerts 0).GeneratorURL }}"
                #         - type: button
                #           text: "Dashboard :grafana:"
                #           url: "{{ (index .Alerts 0).Annotations.dashboard }}"
                #         - type: button
                #           text: "Silence :no_bell:"
                #           url: '{{ template "__alert_silence_link" . }}'
                #         - type: button
                #           text: '{{ template "slack.monzo.link_button_text" . }}'
                #           url: "{{ .CommonAnnotations.link_url }}"
                # - name: slack-code-owners
                #   slack_configs:
                #     - channel: "#{{ .CommonLabels.code_owner_channel }}"
                #       send_resolved: true
                #       title: '{{ template "slack.monzo.title" . }}'
                #       icon_emoji: '{{ template "slack.monzo.icon_emoji" . }}'
                #       color: '{{ template "slack.monzo.color" . }}'
                #       text: '{{ template "slack.monzo.text" . }}'
                #       actions:
                #         - type: button
                #           text: "Runbook :green_book:"
                #           url: "{{ (index .Alerts 0).Annotations.runbook }}"
                #         - type: button
                #           text: "Query :mag:"
                #           url: "{{ (index .Alerts 0).GeneratorURL }}"
                #         - type: button
                #           text: "Dashboard :grafana:"
                #           url: "{{ (index .Alerts 0).Annotations.dashboard }}"
                #         - type: button
                #           text: "Silence :no_bell:"
                #           url: '{{ template "__alert_silence_link" . }}'
                #         - type: button
                #           text: '{{ template "slack.monzo.link_button_text" . }}'
                #           url: "{{ .CommonAnnotations.link_url }}"
                #
            # -- Better alert templates for [slack source](https://gist.github.com/milesbxf/e2744fc90e9c41b47aa47925f8ff6512)
            monzoTemplate:
              enabled: true

            # -- (object) Extra alert templates
            templateFiles:
              {}
              # template_1.tmpl: |-
              #   {{ define "hello" -}}
              #   hello, Victoria!
              #   {{- end }}
              # template_2.tmpl: ""

            # -- (object) Alertmanager ingress configuration
            ingress:
              enabled: false
              # For Kubernetes >= 1.18 you should specify the ingress-controller via the field ingressClassName
              # See https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/#specifying-the-class-of-an-ingress
              # ingressClassName: nginx
              # Values can be templated
              annotations:
                # kubernetes.io/ingress.class: traefik
                # kubernetes.io/tls-acme: "true"
                cert-manager.io/cluster-issuer: letsencrypt
              labels: {}
              path: '{{ .Values.alertmanager.spec.routePrefix | default "/" }}'
              pathType: Prefix

              hosts:
                - alertmanager.domain.com
              # -- Extra paths to prepend to every host configuration. This is useful when working with annotation based services.
              extraPaths: []
              # - path: /*
              #   pathType: Prefix
              #   backend:
              #     service:
              #       name: ssl-redirect
              #       port:
              #         name: service
              tls: []
              #  - secretName: alertmanager-ingress-tls
              #    hosts:
              #      - alertmanager.domain.com

          vmalert:
            # -- VMAlert annotations
            annotations: {}
            # -- Create VMAlert CR
            enabled: true

            # -- Controls whether VMAlert should use VMAgent or VMInsert as a target for remotewrite
            remoteWriteVMAgent: false
            # -- (object) Full spec for VMAlert CRD. Allowed values described [here](https://docs.victoriametrics.com/operator/api#vmalertspec)
            spec:
              nodeSelector:
                kubernetes.io/arch: amd64
              port: "8080"
              selectAllByDefault: true
              image:
                tag: v1.104.0
              evaluationInterval: 15s
              extraArgs:
                http.pathPrefix: "/"

              # External labels to add to all generated recording rules and alerts
              externalLabels: {}

            # -- (object) Extra VMAlert annotation templates
            templateFiles:
              {}
              # template_1.tmpl: |-
              #   {{ define "hello" -}}
              #   hello, Victoria!
              #   {{- end }}
              # template_2.tmpl: ""

            # -- Allows to configure static notifiers, discover notifiers via Consul and DNS,
            # see specification [here](https://docs.victoriametrics.com/vmalert/#notifier-configuration-file).
            # This configuration will be created as separate secret and mounted to VMAlert pod.
            additionalNotifierConfigs:
              {}
              # dns_sd_configs:
              #   - names:
              #       - my.domain.com
              #     type: 'A'
              #     port: 9093
            # -- (object) VMAlert ingress config
            ingress:
              enabled: false
              # For Kubernetes >= 1.18 you should specify the ingress-controller via the field ingressClassName
              # See https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/#specifying-the-class-of-an-ingress
              # ingressClassName: nginx
              # Values can be templated
              annotations:
                # kubernetes.io/ingress.class: traefik
                # kubernetes.io/tls-acme: "true"
                cert-manager.io/cluster-issuer: letsencrypt
              labels: {}
              path: ""
              pathType: Prefix

              hosts:
                - vmalert.domain.com
              # -- Extra paths to prepend to every host configuration. This is useful when working with annotation based services.
              extraPaths: []
              # - path: /*
              #   pathType: Prefix
              #   backend:
              #     service:
              #       name: ssl-redirect
              #       port:
              #         name: service
              tls: []
              #  - secretName: vmalert-ingress-tls
              #    hosts:
              #      - vmalert.domain.com

          vmauth:
            # -- Enable VMAuth CR
            enabled: false
            # -- VMAuth annotations
            annotations: {}
            # -- (object) Full spec for VMAuth CRD. Allowed values described [here](https://docs.victoriametrics.com/operator/api#vmauthspec)
            spec:
              nodeSelector:
                kubernetes.io/arch: amd64
              discover_backend_ips: true
              port: "8427"

          vmagent:
            # -- Create VMAgent CR
            enabled: true
            # -- VMAgent annotations
            annotations: {}
            # -- Remote write configuration of VMAgent, allowed parameters defined in a [spec](https://docs.victoriametrics.com/operator/api#vmagentremotewritespec)
            additionalRemoteWrites:
              []
              #- url: http://some-remote-write/api/v1/write
            # -- (object) Full spec for VMAgent CRD. Allowed values described [here](https://docs.victoriametrics.com/operator/api#vmagentspec)
            spec:
              resources:
                limits:
                  cpu: 1000m
                  memory: 2500Mi
                requests:
                  cpu: 250m
                  memory: 1000Mi
              nodeSelector:
                kubernetes.io/arch: amd64
              port: "8429"
              selectAllByDefault: true
              image:
                tag: v1.104.0
              scrapeInterval: 20s
              externalLabels:
                {}
                # For multi-cluster setups it is useful to use "cluster" label to identify the metrics source.
                # For example:
                # cluster: cluster-name
              extraArgs:
                promscrape.streamParse: "true"
                # Do not store original labels in vmagent's memory by default. This reduces the amount of memory used by vmagent
                # but makes vmagent debugging UI less informative. See: https://docs.victoriametrics.com/vmagent/#relabel-debug
                promscrape.dropOriginalLabels: "true"
            # -- (object) VMAgent ingress configuration
            ingress:
              enabled: false
              # For Kubernetes >= 1.18 you should specify the ingress-controller via the field ingressClassName
              # See https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/#specifying-the-class-of-an-ingress
              # ingressClassName: nginx
              # Values can be templated
              annotations:
                # kubernetes.io/ingress.class: traefik
                # kubernetes.io/tls-acme: "true"
                cert-manager.io/cluster-issuer: letsencrypt
              labels: {}
              path: ""
              pathType: Prefix

              hosts:
                - vmagent.domain.com
              extraPaths: []
              # - path: /*
              #   pathType: Prefix
              #   backend:
              #     service:
              #       name: ssl-redirect
              #       port:
              #         name: service
              tls: []
              #  - secretName: vmagent-ingress-tls
              #    hosts:
              #      - vmagent.domain.com

          # -- Grafana dependency chart configuration. For possible values refer [here](https://github.com/grafana/helm-charts/tree/main/charts/grafana#configuration)

          grafana:
            spec:
              nodeSelector:
                kubernetes.io/arch: amd64

            enabled: true
            # all values for grafana helm chart can be specified here
            sidecar:
              datasources:
                enabled: true
                # -- List of default prometheus compatible datasource configurations.
                # VM `url` will be added to each of them in templates and `type` will be set to defaultDatasourceType if not defined
                default:
                  - name: VictoriaMetrics
                    isDefault: true
                  - name: VictoriaMetrics (DS)
                    isDefault: false
                    type: victoriametrics-datasource
                initDatasources: true
                createVMReplicasDatasources: false
              dashboards:
                provider:
                  name: default
                  orgid: 1
                additionalDashboardLabels: {}
                folder: /var/lib/grafana/dashboards
                defaultFolderName: default
                additionalDashboardAnnotations: {}
                enabled: true
                multicluster: false

            plugins:
              - victoriametrics-logs-datasource

            image:
              registry: docker.io
              repository: grafana/grafana
              tag: "12.0.2"
              pullPolicy: IfNotPresent

            # -- Create datasource configmap even if grafana deployment has been disabled
            forceDeployDatasource: false

            # -- Configure additional grafana datasources (passed through tpl). Check [here](http://docs.grafana.org/administration/provisioning/#datasources) for details
            additionalDataSources: []
            # - name: prometheus-sample
            #   access: proxy
            #   basicAuth: true
            #   basicAuthPassword: pass
            #   basicAuthUser: daco
            #   editable: false
            #   jsonData:
            #       tlsSkipVerify: true
            #   orgId: 1
            #   type: prometheus
            #   url: https://{{ printf "%s-prometheus.svc" .Release.Name }}:9090
            #   version: 1

            defaultDashboardsTimezone: "Australia/Perth"

            persistence:
              enabled: true
              storageClassName: "nfs-ssd"
              accessModes:
                - ReadWriteMany

            # Enabling VictoriaMetrics Datasource in Grafana. See more details here: https://github.com/VictoriaMetrics/grafana-datasource/blob/main/README.md#victoriametrics-datasource-for-grafana
            # Note that Grafana will need internet access to install the datasource plugin.
            # Uncomment the block below, if you want to enable VictoriaMetrics Datasource in Grafana:
            #plugins:
            #  - "https://github.com/VictoriaMetrics/grafana-datasource/releases/download/v0.5.0/victoriametrics-datasource-v0.5.0.zip;victoriametrics-datasource"
            #grafana.ini:
            #  plugins:
            #    # Why VictoriaMetrics datasource is unsigned: https://github.com/VictoriaMetrics/grafana-datasource/blob/main/README.md#why-victoriametrics-datasource-is-unsigned
            #    allow_loading_unsigned_plugins: victoriametrics-datasource

            # Change datasource type in dashboards from Prometheus to VictoriaMetrics.
            # you can use `victoriametrics-datasource` instead of `prometheus` if enabled VictoriaMetrics Datasource above
            defaultDatasourceType: "prometheus"

            ingress:
              enabled: true
              # For Kubernetes >= 1.18 you should specify the ingress-controller via the field ingressClassName
              # See https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/#specifying-the-class-of-an-ingress
              # ingressClassName: nginx
              # Values can be templated
              annotations:
                # kubernetes.io/ingress.class: traefik
                # kubernetes.io/tls-acme: "true"
                cert-manager.io/cluster-issuer: letsencrypt
              labels: {}
              path: /
              pathType: Prefix

              hosts:
                - grafana.initialed85.cc
              # -- Extra paths to prepend to every host configuration. This is useful when working with annotation based services.
              extraPaths: []
              # - path: /*
              #   pathType: Prefix
              #   backend:
              #     service:
              #       name: ssl-redirect
              #       port:
              #         name: service
              tls:
                - secretName: grafana-ingress-tls
                  hosts:
                    - grafana.initialed85.cc

            # -- Grafana VM scrape config
            vmScrape:
              # whether we should create a service scrape resource for grafana
              enabled: true

              # -- [Scrape configuration](https://docs.victoriametrics.com/operator/api#vmservicescrapespec) for Grafana
              spec:
                selector:
                  matchLabels:
                    app.kubernetes.io/name: '{{ include "grafana.name" .Subcharts.grafana }}'
                endpoints:
                  - port: "{{ .Values.grafana.service.portName }}"

          # -- prometheus-node-exporter dependency chart configuration. For possible values check [here](https://github.com/prometheus-community/helm-charts/blob/main/charts/prometheus-node-exporter/values.yaml)
          prometheus-node-exporter:
            enabled: true

            # all values for prometheus-node-exporter helm chart can be specified here
            service:
              # Add the 'node-exporter' label to be used by serviceMonitor to match standard common usage in rules and grafana dashboards
              #
              labels:
                jobLabel: node-exporter
            extraArgs:
              - --collector.filesystem.ignored-mount-points=^/(dev|proc|sys|var/lib/docker/.+|var/lib/kubelet/.+)($|/)
              - --collector.filesystem.ignored-fs-types=^(autofs|binfmt_misc|bpf|cgroup2?|configfs|debugfs|devpts|devtmpfs|fusectl|hugetlbfs|iso9660|mqueue|nsfs|overlay|proc|procfs|pstore|rpc_pipefs|securityfs|selinuxfs|squashfs|sysfs|tracefs)$
            # -- Node Exporter VM scrape config
            vmScrape:
              # whether we should create a service scrape resource for node-exporter
              enabled: true

              # -- [Scrape configuration](https://docs.victoriametrics.com/operator/api#vmservicescrapespec) for Node Exporter
              spec:
                jobLabel: jobLabel
                selector:
                  matchLabels:
                    app.kubernetes.io/name: '{{ include "prometheus-node-exporter.name" (index .Subcharts "prometheus-node-exporter") }}'
                endpoints:
                  - port: metrics
                    metricRelabelConfigs:
                      - action: drop
                        source_labels: [mountpoint]
                        regex: "/var/lib/kubelet/pods.+"

          # -- kube-state-metrics dependency chart configuration. For possible values check [here](https://github.com/prometheus-community/helm-charts/blob/main/charts/kube-state-metrics/values.yaml)
          kube-state-metrics:
            enabled: true
            # -- [Scrape configuration](https://docs.victoriametrics.com/operator/api#vmservicescrapespec) for Kube State Metrics
            vmScrape:
              enabled: true
              spec:
                selector:
                  matchLabels:
                    app.kubernetes.io/name: '{{ include "kube-state-metrics.name" (index .Subcharts "kube-state-metrics") }}'
                    app.kubernetes.io/instance: '{{ include "vm.release" . }}'
                endpoints:
                  - port: http
                    honorLabels: true
                    metricRelabelConfigs:
                      - action: labeldrop
                        regex: (uid|container_id|image_id)
                jobLabel: app.kubernetes.io/name

          # -- Component scraping the kubelets
          kubelet:
            enabled: true
            vmScrapes:
              # -- Enable scraping /metrics/cadvisor from kubelet's service
              cadvisor:
                enabled: true
                spec:
                  path: /metrics/cadvisor
              # -- Enable scraping /metrics/probes from kubelet's service
              probes:
                enabled: true
                spec:
                  path: /metrics/probes
              kubelet:
                spec: {}
            # -- Spec for VMNodeScrape CRD is [here](https://docs.victoriametrics.com/operator/api.html#vmnodescrapespec)
            vmScrape:
              kind: VMNodeScrape
              spec:
                scheme: "https"
                honorLabels: true
                interval: "30s"
                scrapeTimeout: "5s"
                tlsConfig:
                  insecureSkipVerify: true
                  caFile: "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
                bearerTokenFile: "/var/run/secrets/kubernetes.io/serviceaccount/token"
                # drop high cardinality label and useless metrics for cadvisor and kubelet
                metricRelabelConfigs:
                  - action: labeldrop
                    regex: (uid)
                  - action: labeldrop
                    regex: (id|name)
                  - action: drop
                    source_labels: [__name__]
                    regex: (rest_client_request_duration_seconds_bucket|rest_client_request_duration_seconds_sum|rest_client_request_duration_seconds_count)
                relabelConfigs:
                  - action: labelmap
                    regex: __meta_kubernetes_node_label_(.+)
                  - sourceLabels: [__metrics_path__]
                    targetLabel: metrics_path
                  - targetLabel: "job"
                    replacement: "kubelet"
                # ignore timestamps of cadvisor's metrics by default
                # more info here https://github.com/VictoriaMetrics/VictoriaMetrics/issues/4697#issuecomment-1656540535
                honorTimestamps: false

          # Component scraping the kube api server
          kubeApiServer:
            # -- Enable Kube Api Server metrics scraping
            enabled: true
            # -- Spec for VMServiceScrape CRD is [here](https://docs.victoriametrics.com/operator/api.html#vmservicescrapespec)
            vmScrape:
              spec:
                endpoints:
                  - bearerTokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token
                    # bearerTokenSecret:
                    #   key: ""
                    port: https
                    scheme: https
                    tlsConfig:
                      caFile: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
                      serverName: kubernetes
                jobLabel: component
                namespaceSelector:
                  matchNames:
                    - default
                selector:
                  matchLabels:
                    component: apiserver
                    provider: kubernetes

          # Component scraping the kube controller manager
          kubeControllerManager:
            # -- Enable kube controller manager metrics scraping
            enabled: true

            # -- If your kube controller manager is not deployed as a pod, specify IPs it can be found on
            endpoints: []
            # - 10.141.4.22
            # - 10.141.4.23
            # - 10.141.4.24

            # If using kubeControllerManager.endpoints only the port and targetPort are used
            service:
              # -- Create service for kube controller manager metrics scraping
              enabled: true
              # -- Kube controller manager service port
              port: 10257
              # -- Kube controller manager service target port
              targetPort: 10257
              # -- Kube controller manager service pod selector
              selector:
                component: kube-controller-manager

            # -- Spec for VMServiceScrape CRD is [here](https://docs.victoriametrics.com/operator/api.html#vmservicescrapespec)
            vmScrape:
              spec:
                jobLabel: jobLabel
                namespaceSelector:
                  matchNames:
                    - "kube-system"
                endpoints:
                  - bearerTokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token
                    # bearerTokenSecret:
                    #   key: ""
                    port: http-metrics
                    scheme: https
                    tlsConfig:
                      caFile: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
                      serverName: kubernetes

          # Component scraping kubeDns. Use either this or coreDns
          kubeDns:
            # -- Enabled KubeDNS metrics scraping
            enabled: false
            service:
              # -- Create Service for KubeDNS metrics
              enabled: false
              # -- KubeDNS service ports
              ports:
                dnsmasq:
                  port: 10054
                  targetPort: 10054
                skydns:
                  port: 10055
                  targetPort: 10055
              # -- KubeDNS service pods selector
              selector:
                k8s-app: kube-dns
            # -- Spec for VMServiceScrape CRD is [here](https://docs.victoriametrics.com/operator/api.html#vmservicescrapespec)
            vmScrape:
              spec:
                jobLabel: jobLabel
                namespaceSelector:
                  matchNames: [kube-system]
                endpoints:
                  - port: http-metrics-dnsmasq
                    bearerTokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token
                  - port: http-metrics-skydns
                    bearerTokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token

          # Component scraping coreDns. Use either this or kubeDns
          coreDns:
            # -- Enabled CoreDNS metrics scraping
            enabled: true
            service:
              # -- Create service for CoreDNS metrics
              enabled: true
              # -- CoreDNS service port
              port: 9153
              # -- CoreDNS service target port
              targetPort: 9153
              # -- CoreDNS service pod selector
              selector:
                k8s-app: kube-dns

            # -- Spec for VMServiceScrape CRD is [here](https://docs.victoriametrics.com/operator/api.html#vmservicescrapespec)
            vmScrape:
              spec:
                jobLabel: jobLabel
                namespaceSelector:
                  matchNames: [kube-system]
                endpoints:
                  - port: http-metrics
                    bearerTokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token

          # Component scraping etcd
          kubeEtcd:
            # -- Enabled KubeETCD metrics scraping
            enabled: true

            # -- If your etcd is not deployed as a pod, specify IPs it can be found on
            endpoints: []
            # - 10.141.4.22
            # - 10.141.4.23
            # - 10.141.4.24

            # Etcd service. If using kubeEtcd.endpoints only the port and targetPort are used
            service:
              # -- Enable service for ETCD metrics scraping
              enabled: true
              # -- ETCD service port
              port: 2379
              # -- ETCD service target port
              targetPort: 2379
              # -- ETCD service pods selector
              selector:
                component: etcd

            # -- Spec for VMServiceScrape CRD is [here](https://docs.victoriametrics.com/operator/api.html#vmservicescrapespec)
            vmScrape:
              spec:
                jobLabel: jobLabel
                namespaceSelector:
                  matchNames: [kube-system]
                endpoints:
                  - bearerTokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token
                    # bearerTokenSecret:
                    #   key: ""
                    port: http-metrics
                    scheme: https
                    tlsConfig:
                      caFile: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt

          # Component scraping kube scheduler
          kubeScheduler:
            # -- Enable KubeScheduler metrics scraping
            enabled: true

            # -- If your kube scheduler is not deployed as a pod, specify IPs it can be found on
            endpoints: []
            # - 10.141.4.22
            # - 10.141.4.23
            # - 10.141.4.24

            # If using kubeScheduler.endpoints only the port and targetPort are used
            service:
              # -- Enable service for KubeScheduler metrics scrape
              enabled: true
              # -- KubeScheduler service port
              port: 10259
              # -- KubeScheduler service target port
              targetPort: 10259
              # -- KubeScheduler service pod selector
              selector:
                component: kube-scheduler

            # -- Spec for VMServiceScrape CRD is [here](https://docs.victoriametrics.com/operator/api.html#vmservicescrapespec)
            vmScrape:
              spec:
                jobLabel: jobLabel
                namespaceSelector:
                  matchNames: [kube-system]
                endpoints:
                  - bearerTokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token
                    # bearerTokenSecret:
                    #   key: ""
                    port: http-metrics
                    scheme: https
                    tlsConfig:
                      caFile: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt

          # Component scraping kube proxy
          kubeProxy:
            # -- Enable kube proxy metrics scraping
            enabled: false

            # -- If your kube proxy is not deployed as a pod, specify IPs it can be found on
            endpoints: []
            # - 10.141.4.22
            # - 10.141.4.23
            # - 10.141.4.24

            service:
              # -- Enable service for kube proxy metrics scraping
              enabled: true
              # -- Kube proxy service port
              port: 10249
              # -- Kube proxy service target port
              targetPort: 10249
              # -- Kube proxy service pod selector
              selector:
                k8s-app: kube-proxy

            # -- Spec for VMServiceScrape CRD is [here](https://docs.victoriametrics.com/operator/api.html#vmservicescrapespec)
            vmScrape:
              spec:
                jobLabel: jobLabel
                namespaceSelector:
                  matchNames: [kube-system]
                endpoints:
                  - bearerTokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token
                    # bearerTokenSecret:
                    #   key: ""
                    port: http-metrics
                    scheme: https
                    tlsConfig:
                      caFile: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt

          # --  Install VM operator CRDs
          crds:
            enabled: true

          # -- Install prometheus operator CRDs
          prometheus-operator-crds:
            enabled: false

          # -- Add extra objects dynamically to this chart
          extraObjects: []
    #
    # victorialogs
    #
    - path: applications/victorialogs
      repoURL: https://github.com/initialed85/home-ops
      targetRevision: HEAD
    - chart: victoria-logs-single
      targetRevision: 0.8.16
      repoURL: https://victoriametrics.github.io/helm-charts/
      helm:
        releaseName: vls
        valuesObject:
          # Default values for victoria-logs.
          # This is a YAML-formatted file.
          # Declare variables to be passed into your templates.
          global:
            # -- Image pull secrets, that can be shared across multiple helm charts
            imagePullSecrets: []
            image:
              # -- Image registry, that can be shared across multiple helm charts
              registry: ""
            # -- Openshift security context compatibility configuration
            compatibility:
              openshift:
                adaptSecurityContext: "auto"
            cluster:
              # -- K8s cluster domain suffix, uses for building storage pods' FQDN. Details are [here](https://kubernetes.io/docs/tasks/administer-cluster/dns-custom-nameservers/)
              dnsDomain: cluster.local.

          # -- Override chart name
          nameOverride: ""

          # -- Print chart notes
          printNotes: true

          # -- See `kubectl explain poddisruptionbudget.spec` for more. Details are [here](https://kubernetes.io/docs/tasks/run-application/configure-pdb/)
          podDisruptionBudget:
            enabled: false
            #  minAvailable: 1
            #  maxUnavailable: 1
            # -- PodDisruptionBudget extra labels
            extraLabels: {}

          server:
            # -- Enable deployment of server component. Deployed as StatefulSet
            enabled: true
            image:
              # -- Image registry
              registry: ""
              # -- Image repository
              repository: victoriametrics/victoria-logs
              # -- Image tag
              tag: ""
              # -- Image tag suffix, which is appended to `Chart.AppVersion` if no `server.image.tag` is defined
              variant: victorialogs
              # -- Image pull policy
              pullPolicy: IfNotPresent
            # -- Image pull secrets
            imagePullSecrets: []
            # -- Replica count
            replicaCount: 1
            # -- Name of Priority Class
            priorityClassName: ""
            # -- Data retention period. Possible units character: h(ours), d(ays), w(eeks), y(ears), if no unit character specified - month. The minimum retention period is 24h. See these [docs](https://docs.victoriametrics.com/victorialogs/#retention)
            retentionPeriod: 7d
            # -- Data retention max capacity. Default unit is GiB. See these [docs](https://docs.victoriametrics.com/victorialogs/#retention-by-disk-space-usage)
            retentionDiskSpaceUsage: "63" # because of the 64 GB persistent volume claim
            # -- Extra command line arguments for container of component
            extraArgs:
              envflag.enable: true
              envflag.prefix: VM_
              loggerFormat: json
              httpListenAddr: :9428

            # -- Additional hostPath mounts
            extraHostPathMounts:
              []
              #- name: certs-dir
              #  mountPath: /etc/kubernetes/certs
              #  subPath: ""
              #  hostPath: /etc/kubernetes/certs
              #  readOnly: true

            # -- Extra Volumes for the pod
            extraVolumes:
              []
              #- name: example
              #  configMap:
              #   name: example

            # -- Extra Volume Mounts for the container
            extraVolumeMounts:
              []
              # - name: example
              #   mountPath: /example

            # -- Extra containers to run in a pod with Victoria Logs container
            extraContainers:
              []
              #- name: config-reloader
              #  image: reloader-image

            # -- Init containers for Victoria Logs Pod
            initContainers: []

            # -- Node tolerations for server scheduling to nodes with taints. Details are [here](https://kubernetes.io/docs/concepts/configuration/assign-pod-node/)
            tolerations:
              []
              # - key: "key"
              #   operator: "Equal|Exists"
              #   value: "value"
              #   effect: "NoSchedule|PreferNoSchedule"

            # -- Pod's node selector. Details are [here](https://kubernetes.io/docs/user-guide/node-selection/)
            nodeSelector: {}

            # -- Pod topologySpreadConstraints
            topologySpreadConstraints: []

            # -- Pod affinity
            affinity: {}

            # -- Additional environment variables (ex.: secret tokens, flags). Details are [here](https://github.com/VictoriaMetrics/VictoriaMetrics#environment-variables)
            env: []

            # -- Specify alternative source for env variables
            envFrom:
              []
              #- configMapRef:
              #    name: special-config

            # -- Container workdir
            containerWorkingDir: ""

            # -- Use an alternate scheduler, e.g. "stork". Check details [here](https://kubernetes.io/docs/tasks/administer-cluster/configure-multiple-schedulers/)
            #
            # schedulerName:

            emptyDir: {}
            persistentVolume:
              # -- Create/use Persistent Volume Claim for server component. Empty dir if false
              enabled: true

              # -- Override Persistent Volume Claim name
              name: ""

              # -- Array of access modes. Must match those of existing PV or dynamic provisioner. Details are [here](http://kubernetes.io/docs/user-guide/persistent-volumes/)
              accessModes:
                - ReadWriteMany
              # -- Persistant volume annotations
              annotations: {}

              # -- StorageClass to use for persistent volume. Requires server.persistentVolume.enabled: true. If defined, PVC created automatically
              storageClassName: "longhorn"

              # -- Existing Claim name. If defined, PVC must be created manually before volume will be bound
              existingClaim: ""

              # -- Bind Persistent Volume by labels. Must match all labels of targeted PV.
              matchLabels: {}

              # -- Mount path. Server data Persistent Volume mount root path.
              mountPath: /storage
              # -- Mount subpath
              subPath: ""
              # -- Size of the volume. Should be calculated based on the logs you send and retention policy you set.
              size: 128Gi

            # -- StatefulSet/Deployment additional labels
            extraLabels: {}
            # -- Pod's additional labels
            podLabels: {}
            # -- Pod's annotations
            podAnnotations: {}
            # -- Pod's management policy
            podManagementPolicy: OrderedReady

            # -- Resource object. Details are [here](http://kubernetes.io/docs/user-guide/compute-resources/)
            resources:
              {}
              # limits:
              #   cpu: 500m
              #   memory: 512Mi
              # requests:
              #   cpu: 500m
              #   memory: 512Mi

            probe:
              # -- Indicates whether the Container is ready to service requests. If the readiness probe fails, the endpoints controller removes the Pod's IP address from the endpoints of all Services that match the Pod. The default state of readiness before the initial delay is Failure. If a Container does not provide a readiness probe, the default state is Success.
              readiness:
                httpGet: {}
                initialDelaySeconds: 5
                periodSeconds: 15
                timeoutSeconds: 5
                failureThreshold: 3

              # -- Indicates whether the Container is running. If the liveness probe fails, the kubelet kills the Container, and the Container is subjected to its restart policy. If a Container does not provide a liveness probe, the default state is Success.
              liveness:
                tcpSocket: {}
                initialDelaySeconds: 30
                periodSeconds: 30
                timeoutSeconds: 5
                failureThreshold: 10

              # -- Indicates whether the Container is done with potentially costly initialization. If set it is executed first. If it fails Container is restarted. If it succeeds liveness and readiness probes takes over.
              startup: {}
              # tcpSocket: {}
              # failureThreshold: 30
              # periodSeconds: 15
              # successThreshold: 1
              # timeoutSeconds: 5

            # -- Security context to be added to server pods
            securityContext:
              enabled: true
              allowPrivilegeEscalation: false
              capabilities:
                drop:
                  - ALL
              readOnlyRootFilesystem: true

            # -- Pod's security context. Details are [here](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)
            podSecurityContext:
              enabled: true
              fsGroup: 2000
              runAsNonRoot: true
              runAsUser: 1000

            ingress:
              # -- Enable deployment of ingress for server component
              enabled: true

              # -- Ingress annotations
              annotations:
                # kubernetes.io/ingress.class: traefik
                # kubernetes.io/tls-acme: 'true'
                cert-manager.io/cluster-issuer: letsencrypt
                # (namespace)-(name)@kubernetescrd
                traefik.ingress.kubernetes.io/router.middlewares: monitoring-victorialogs-whitelist@kubernetescrd

              # -- Ingress extra labels
              extraLabels: {}

              # -- Array of host objects
              hosts:
                - name: vlogs.initialed85.cc
                  path:
                    - /
                  port: http

              # -- Array of TLS objects
              tls:
                - secretName: vlogs-ingress-tls
                  hosts:
                    - vlogs.initialed85.cc

              # -- Ingress controller class name
              ingressClassName: "traefik"

              # -- Ingress path type
              pathType: Prefix

            service:
              # -- Service annotations
              annotations: {}
              # -- Service labels
              labels: {}
              # -- Service ClusterIP
              clusterIP: None
              # -- Service external IPs. Details are [here]( https://kubernetes.io/docs/user-guide/services/#external-ips)
              externalIPs: []
              # -- Service load balancer IP
              loadBalancerIP: ""
              # -- Load balancer source range
              loadBalancerSourceRanges: []
              # -- Target port
              targetPort: http
              # -- Service port
              servicePort: 9428
              # -- Node port
              # nodePort: 30000
              # -- Service type
              type: ClusterIP
              # -- Service external traffic policy. Check [here](https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip) for details
              externalTrafficPolicy: ""
              # -- Health check node port for a service. Check [here](https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip) for details
              healthCheckNodePort: ""
              # -- Service IP family policy. Check [here](https://kubernetes.io/docs/concepts/services-networking/dual-stack/#services) for details.
              ipFamilyPolicy: ""
              # -- List of service IP families. Check [here](https://kubernetes.io/docs/concepts/services-networking/dual-stack/#services) for details.
              ipFamilies: []

            statefulSet:
              # -- Creates statefulset instead of deployment, useful when you want to keep the cache
              enabled: true
              # -- Deploy order policy for StatefulSet pods
              podManagementPolicy: OrderedReady
              # -- StatefulSet update strategy. Check [here](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies) for details.
              updateStrategy:
                {}
                # type: RollingUpdate

            # -- Pod's termination grace period in seconds
            terminationGracePeriodSeconds: 60
            serviceMonitor:
              # -- Enable deployment of Service Monitor for server component. This is Prometheus operator object
              enabled: false
              # -- Service Monitor labels
              extraLabels: {}
              # -- Service Monitor annotations
              annotations: {}
              # -- Basic auth params for Service Monitor
              basicAuth: {}
              # -- Commented. Prometheus scrape interval for server component
              #    interval: 15s
              # -- Commented. Prometheus pre-scrape timeout for server component
              #    scrapeTimeout: 5s
              # -- Commented. HTTP scheme to use for scraping.
              #    scheme: https
              # -- Commented. TLS configuration to use when scraping the endpoint
              #    tlsConfig:
              #      insecureSkipVerify: true
              # -- Service Monitor relabelings
              relabelings: []
              # -- Service Monitor metricRelabelings
              metricRelabelings: []
              # -- Service Monitor target port
              targetPort: http
            vmServiceScrape:
              # -- Enable deployment of VMServiceScrape for server component. This is Victoria Metrics operator object
              enabled: true
              # VMServiceScrape labels
              extraLabels: {}
              # VMServiceScrape annotations
              annotations: {}
              # -- Commented. VMServiceScrape scrape interval for server component
              #    interval: 15s
              # -- Commented. VMServiceScrape pre-scrape timeout for server component
              #    scrapeTimeout: 5s
              # -- Commented. HTTP scheme to use for scraping.
              #    scheme: https
              # -- Commented. TLS configuration to use when scraping the endpoint
              #    tlsConfig:
              #      insecureSkipVerify: true
              relabelings: []
              metricRelabelings: []
              # -- target port
              targetPort: http

          # -- Values for [vector helm chart](https://github.com/vectordotdev/helm-charts/tree/develop/charts/vector)
          vector:
            # -- Enable deployment of vector
            enabled: true
            role: Agent
            dataDir: /vector-data-dir
            resources: {}
            args:
              - -w
              - --config-dir
              - /etc/vector/
            containerPorts:
              - name: prom-exporter
                containerPort: 9090
                protocol: TCP
            service:
              enabled: true
              type: LoadBalancer
              externalTrafficPolicy: Local
              ports:
                - name: syslog-tcp
                  port: 514
                  protocol: TCP
                  targetPort: 514
                - name: syslog-udp
                  port: 514
                  protocol: UDP
                  targetPort: 514

            existingConfigMaps:
              - vl-config
            # -- Forces custom configuration creation in a given namespace even if vector.enabled is false
            customConfigNamespace: ""
            customConfig:
              data_dir: /vector-data-dir

              api:
                enabled: false
                address: 0.0.0.0:8686
                playground: true

              #
              # input
              #

              sources:
                k8s:
                  type: kubernetes_logs

                internal_metrics:
                  type: internal_metrics

                syslog_tcp:
                  type: syslog
                  address: 0.0.0.0:514
                  mode: tcp
                  permit_origin: ["0.0.0.0/0"]

                syslog_udp:
                  type: syslog
                  address: 0.0.0.0:514
                  mode: udp
                  permit_origin: ["0.0.0.0/0"]

              #
              # transform
              #

              transforms:
                parser:
                  type: remap
                  inputs: [k8s, syslog_tcp, syslog_udp]
                  source: |
                    .log = parse_json(.message) ?? .message

              #
              # output
              #

              sinks:
                exporter:
                  type: prometheus_exporter
                  address: 0.0.0.0:9090
                  inputs: [internal_metrics]

                vlogs:
                  type: elasticsearch
                  inputs: [parser]
                  endpoints: << include "vlogs.es.urls" . >>
                  mode: bulk
                  api_version: v8
                  compression: gzip
                  healthcheck:
                    enabled: false
                  request:
                    headers:
                      VL-Time-Field: timestamp
                      VL-Stream-Fields: stream,kubernetes.pod_name,kubernetes.container_name,kubernetes.pod_namespace
                      VL-Msg-Field: message,msg,_msg,Message,log.msg,log.message,log.Message,log
                      AccountID: "0"
                      ProjectID: "0"

                # console:
                #   type: console
                #   inputs: []
                #   encoding:
                #     codec: json

          # -- Add extra specs dynamically to this chart
          extraObjects: []

          dashboards:
            # -- Create VictoriaLogs dashboards
            enabled: false
            # -- Dashboard labels
            labels: {}
            #  grafana_dashboard: "1"
            # -- Dashboard annotations
            annotations: {}
            # -- Override default namespace, where to create dashboards
            namespace: ""
            grafanaOperator:
              enabled: false
              spec:
                instanceSelector:
                  matchLabels:
                    dashboards: "grafana"
                allowCrossNamespaceImport: false
